<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <title>Explaining Promises | kalmas.net</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <link href="https://fonts.googleapis.com/css?family=Cinzel|Ubuntu+Mono|Lora" rel="stylesheet">

  <link rel="stylesheet" href="https://kalmas.net/css/reset.css">
  <link rel="stylesheet" href="https://kalmas.net/css/style.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/hopscotch.min.css" />
</head>
<body>

<section class="section">
  <div class="container">
    <nav class="margin-bottom-lg">
      <h1 class="site-title mono"><a class="no-dec" href="https://kalmas.net">kalmas.net</a></h1>
      <ul id="links">
        <li><a class="mono" href="/blog">Blog</a></li>
        <li><a class="mono" href="https://github.com/kalmas">GitHub</a></li>
        <li><a class="mono" href="https://github.com/kalmas/resume">Resume</a></li>
      </ul>
    </nav>
  </div>
</section>

<section class="section margin-bottom-xlg">
  <div class="container">
    <h2 class="size-medium grey">February 15, 2014</h2>
    <h1>Explaining Promises</h1>
    <div class="content">
      <div class="paragraph">
<p>I&#8217;ve been working with node a lot recently, and as a result I&#8217;ve been reading a lot about managing asynchronous code. I&#8217;ve found that I particularly enjoy using the promises pattern, but I haven&#8217;t yet taken the time to step back and fully contemplate how (if) it is benefiting my code. So, I&#8217;ve decided to write a post explaining the basic usage  of promises, as a thought exercise for myself and hopefully as a useful guide for someone new to the concept. Here goes&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start by looking at a simple piece of asynchronous code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var asyncGetMessage = function (callback) {
    var message = 'an asynchronous "hello!"',
        err = null;
    setTimeout(function () {
        callback(err, message);
    }, 1000);
};

asyncGetMessage(function (err, message) {
    if(err) {
        throw new Error('whoops');
    } else {
        console.log(message);
    }
});

console.log('a synchronous "hi"');</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://jsfiddle.net/kalmas/x2Q4y/11/">See the jsFiddle.</a></p>
</div>
<div class="paragraph">
<p>The example is obviously contrived (the <code>asyncGetMessage</code> function is only asynchronous because <code>setTimeout</code> is used to explicitly delay the response), but it illustrates a pattern thats common in javascript: a function that will return a result eventually is given a callback function containing code to be run once the result is available. In this example, the callback takes a message parameter and prints it out with <code>console.log</code>. Because the callback isn&#8217;t invoked until after 1000 milliseconds have passed, we see the second call to <code>console.log</code> (<code>console.log('a synchronous "hi"');</code>) execute first, followed by the call in the callback function shortly after.</p>
</div>
<div class="paragraph">
<p>Ok, so there&#8217;s no problem with the code above. It&#8217;s readable and concise, and I&#8217;d probably argue that refactoring to use promises would be overkill. But let&#8217;s take our example one step further.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var asyncGetMessage = function (callback) {
    var message = 'an asynchronous "hello!"',
        err = null;
    setTimeout(function () {
        callback(err, message);
    }, 1000);
};

var asyncCapitalize = function (input, callback) {
    var message = input.toUpperCase(),
        err = null;
    setTimeout(function () {
        callback(err, message);
    }, 1000);
};

var asyncPrint = function (input, callback) {
    var err = null;
    setTimeout(function () {
        console.log(input);
        callback(err);
    }, 1000);
};

asyncGetMessage(function (err, message) {
    if (err) {
        throw new Error('an error here');
    } else {
        asyncCapitalize(message, function (err, message) {
            if (err) {
                throw new Error('an error there');
            } else {
                asyncPrint(message, function (err) {
                    if (err) {
                        throw new Error('everywhere an error error');
                    } else {
                        console.log('finally done.');
                    }
                });
            }
        });
    }
});

console.log('a synchronous "hi"');</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://jsfiddle.net/kalmas/vpVgX/1/">See the jsFiddle.</a></p>
</div>
<div class="paragraph">
<p>The above is a logical progression of our example (or as logical as we can be about useless code). Now when we get the result back from <code>asyncGetMessage</code> we pass the result to another asynchronous function, <code>asyncCaptialize</code>, which in turn sends its result to <code>asyncPrint</code>, finally we notify the console that everything is done.</p>
</div>
<div class="paragraph">
<p>Each step is preformed by means of a function handed into the preceding function. The result is a pile of callbacks nested 3 layers deep. Even though our process is trivial, the asynchronous nature of our functions compounds the complexity of our program at every step. As the callbacks are nested deeper and deeper they become more difficult to read, to work on, and to understand. This is the point at which promises can help us improve our code.</p>
</div>
<div class="paragraph">
<p>A promise flips the idea of a callback upside down: instead of sending a piece of code to be evaluated after resolution into a function, the function returns an object with the ability to alert the calling context when resolution occurs. The returned object is called a promise because it represents a promise to provide a value when (and if) it becomes available.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at our first piece of code rewritten to use promises.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Q = require('q');

var consoleLine = "&lt;p class=\"console-line\"&gt;&lt;/p&gt;";
console = {
    log: function (text) {
        $("#console-log").append($(consoleLine).html(text));
    }
};

var asyncGetMessage = function () {
    var deferred = Q.defer(),
        message = 'an asynchronous "hello!"',
        err = null;
    setTimeout(function () {
        if (err) {
            deferred.reject(err);
        } else {
            deferred.resolve(message);
        }
    }, 1000);

    return deferred.promise;
};

var promiseToGetMessage = asyncGetMessage();
promiseToGetMessage.then(function (message) {
    console.log(message);
}, function (err) {
    console.log('Error! ' + err)
});

console.log('a synchronous "hi"');</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://jsfiddle.net/a5TdL/2/">See the jsFiddle.</a></p>
</div>
<div class="paragraph">
<p>Now <code>asyncGetMessage</code> returns a promise, care of <a href="https://github.com/kriskowal/q">the super-fantastic Q library</a>. The promise provides a <code>then</code> method which accepts 2 handler functions. The first gets called with the message on success, the second with an error on failure. This looks a bit cleaner than our first example (to me anyway), but when callbacks start to stack up, promises really shine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var Q = require('q');

var asyncGetMessage = function () {
    var deferred = Q.defer(),
        message = 'an asynchronous "hello!"',
        err = null;
    setTimeout(function () {
        if (err) {
            deferred.reject(err);
        } else {
            deferred.resolve(message);
        }
    }, 1000);

    return deferred.promise;
};

var asyncCapitalize = function (input) {
    var deferred = Q.defer(),
        message = input.toUpperCase(),
        err = null;
    setTimeout(function () {
        if (err) {
            deferred.reject(err);
        } else {
            deferred.resolve(message);
        }
    }, 1000);

    return deferred.promise;
};

var asyncPrint = function (input, callback) {
    var deferred = Q.defer(),
        err = null;
    setTimeout(function () {
        console.log(input);
        if (err) {
            deferred.reject(err);
        } else {
            deferred.resolve();
        }
    }, 1000);

    return deferred.promise;
};

var promiseToGetMessage = asyncGetMessage();
promiseToGetMessage.then(function (message) {
    var promiseToCaptializeMessage = asyncCapitalize(message);
    return promiseToCaptializeMessage;
}).then(function (message) {
    var promiseToPrintMessage = asyncPrint(message);
    return promiseToPrintMessage;
}).then(function () {
    console.log('finally done');
}).fail(function (err) {
    console.log('something went horribly wrong!! ' + err);
});

console.log('a synchronous "hi"');</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://jsfiddle.net/2E8Ts/3/">See the jsFiddle.</a></p>
</div>
<div class="paragraph">
<p>Check it out, our code now only goes one indentation deep (down from six). Within each success handler we return a promise for the next step, achieving the same result as passing a callback from within a callback. This promises chain also gives us a cleaner way to deal with errors: a failure from any promise will pass an error to the failure handler set in <code>fail()</code> and stop the process.</p>
</div>
<div class="paragraph">
<p>When I first encountered promises, I conceptualized the idea like this.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/explaining-promises-comic.jpg" alt="Promises Comic"></span></p>
</div>
<div class="sect1">
<h2 id="_promising_asynchronicity">Promising Asynchronicity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I think that the readability gain alone makes a strong case for using promises, but there is another important feature promises provide that can improve our code. Promises guarantee that the resolution of a function will be asynchronous. Consider the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var toPrint,
sometimesAsync = function (shouldIBeAsync, callback) {
    var message = 'an asynchronous "hello!"',
        err = null;
    if (shouldIBeAsync) {
        setTimeout(function () {
            callback(err, message);
        }, 1000);
    } else {
        callback(err, message);
    }
};

setTimeout(function () {
    console.log(toPrint);
}, 2000);

sometimesAsync(true, function (err, message) {
    toPrint = message;
});

toPrint = 'a synchronous "hi"';</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://jsfiddle.net/6L9DQ/6/">See the jsFiddle.</a></p>
</div>
<div class="paragraph">
<p>Try running the example with <code>shouldIBeAsync</code> set to <code>false</code>, you will see that the output changes. The reason is that <code>sometimesAsync</code> may invoke its callback either immediately or asynchronously. The result is that when <code>shouldIBeAsync</code> is <code>true</code>, <code>toPrint</code> is first set to <code>'a synchronous "hi"'</code> and then changed to <code>'an asynchronous "hello!"'</code> a second later. When <code>shouldIBeAsync</code> is <code>false</code>, <code>toPrint</code> is first set to 'an asynchronous "hello!"' (when <code>sometimesAsync</code> is invoked) and then changed to <code>'a synchronous "hi"'</code>. As you might imagine, this can cause problems. In fact this behavior is so troublesome it has been termed (hilariously) as <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">“releasing Zalgo”</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the same code using promises.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var toPrint,
sometimesAsync = function (shouldIBeAsync) {
    var deferred = Q.defer(),
        message = 'an asynchronous "hello!"',
        err = null;
    if (shouldIBeAsync) {
        setTimeout(function () {
            deferred.resolve(message);
        }, 1000);
    } else {
        deferred.resolve(message);
    }

    return deferred.promise;
};

setTimeout(function () {
    console.log(toPrint);
}, 2000);

sometimesAsync(true).then(function (message) {
    toPrint = message;
});

toPrint = 'a synchronous "hi"';</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://jsfiddle.net/LK6Gv/1/">See the jsFiddle.</a></p>
</div>
<div class="paragraph">
<p>Now the output will always be the same, whether the function resolves synchronously or asynchronously. Thus promises give us a simple way to ensure that a sometimes asynchronous function is always asynchronous, and that Zalgo stays contained.</p>
</div>
<div class="paragraph">
<p>Promises provide a clever abstraction that can help make your code easier to read and reason about. The Q library makes using promises easy (I neglected to mention that it can even convert standard callback accepting functions into promise returning functions, it&#8217;s pretty slick). If you&#8217;re looking for a way to flatten your callback pile, give promises a try, they&#8217;re addictive.</p>
</div>
</div>
</div>

    </div>
  </div>
</section>
<section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
