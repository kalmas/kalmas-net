<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <title>Find and Replace with Mongoose | kalmas.net</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <link href="https://fonts.googleapis.com/css?family=Cinzel|Ubuntu+Mono|Lora" rel="stylesheet">

  <link rel="stylesheet" href="https://kalmas.net/css/reset.css">
  <link rel="stylesheet" href="https://kalmas.net/css/style.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/hopscotch.min.css" />
</head>
<body>

<section class="section">
  <div class="container">
    <nav class="margin-bottom-lg">
      <h1 class="site-title mono"><a class="no-dec" href="https://kalmas.net">kalmas.net</a></h1>
      <ul id="links">
        <li><a class="mono" href="/blog">Blog</a></li>
        <li><a class="mono" href="https://github.com/kalmas">GitHub</a></li>
        <li><a class="mono" href="https://github.com/kalmas/resume">Resume</a></li>
      </ul>
    </nav>
  </div>
</section>

<section class="section margin-bottom-xlg">
  <div class="container">
    <h2 class="size-medium grey">February 23, 2014</h2>
    <h1>Find and Replace with Mongoose</h1>
    <div class="content">
      <div class="paragraph">
<p>I recently discovered a weird gap in the functionality of Mongoose. I&#8217;ve been building a number of simple data caching services using Node, and <a href="http://mongoosejs.com/">Mongoose</a> has been my swiss army knife for all things Mongo related. Schema definition, server connection, collection management, access to native driver; Mongoose makes it simple. All in all, it&#8217;s a fantastic tool that has drastically reduced my lines of code dedicated db stuff.</p>
</div>
<div class="paragraph">
<p>The gap that I mentioned has to do with a use case that I would assume is fairly common: I want to insert a document into a collection, replacing the existing version of the document if it exists. For example, I have new document with <code>_id: 123</code>. If there is no document with the same <code>_id</code> already in the collection, I want to insert the new document. If there is a document with the same <code>_id</code>, I want to remove the old one and then insert the new one.</p>
</div>
<div class="paragraph">
<p>Based on the assumption that you found this page while struggling with the same problem, I&#8217;ll skip the explination and give you the answer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">/*
 * My hacky solution for doing a find and replace with Mongoose
 *
 * 1. Validate object
 * 2. Then strip extra fields
 * 3. And finally upsert
 */
var weirdObject = { aNumericField: 14, weirdUnexpectedField: 'Tom Selleck' };
var weirdDocument = new CoolDocument(weirdObject);
weirdDocument.validate(function (err) { // Validate
	if (err) { throw new Error('Validation failed :('); }

	var cleanObject = weirdDocument.toObject(); // Strip extra fields

	collection.update({ _id: 123 }, // Upsert
		cleanObject,
		{ upsert: true },
		callback);
});

// Stored in db:
// { _id: 123, aNumericField: 14 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that that&#8217;s out of the way, I&#8217;ll walk you through the process by which I arrived here.</p>
</div>
<div class="paragraph">
<p>Oh you&#8217;re still reading, okay&#8230;&#8203; Let&#8217;s begin with how I could achieve this behavior with <a href="https://github.com/mongodb/node-mongodb-native">node-mongodb-native</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">collection.update({ _id: 123 },
	newDocument,
	{ upsert: true },
	callback);</code></pre>
</div>
</div>
<div class="paragraph">
<p>But why would I use the native driver when I have a cool utility lib to play with? Surely Mongoose has some sugar I can use.</p>
</div>
<div class="paragraph">
<p>The standard save in Mongoose looks like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var coolObject = { _id: 123, aNumericField: 3 };
var coolDocument = new CoolDocument(coolObject);
coolDocument.save();</code></pre>
</div>
</div>
<div class="paragraph">
<p>But that won&#8217;t work because <code>save</code> doesn&#8217;t have the ability to update an existing document, so I&#8217;d need to use some clunky find-and-then-save process. I should be able to do better.</p>
</div>
<div class="paragraph">
<p>Turns out Mongoose provides a <code>findOneAndUpdate</code> method on its model objects. That has a promising name and a signature identical to node-mongodb-native&#8217;s <code>collection.update</code>, but unfortunately it has 2 major flaws. The first is that <code>findOneAndUpdate</code> totally bypasses schema validation and any other Mongoose middlewear.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">/*
 * No good: Will upsert without forcing schema validation
 */
var invalidObject = { aNumericField: 'what? a string?' };
model.findOneAndUpdate({ _id: 123 },
	invalidObject,
	{ upsert: true },
	callback);

// Stored in db:
// { _id: 123, aNumericField: 'what? a string?' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Well, I&#8217;m not using Mongoose to have all of my lovingly crafted schemas ignored, so that&#8217;s a pain, but there&#8217;s more. While <code>findOneAndUpdate</code> looks and sounds a lot like <code>collection.update</code>, it doesn&#8217;t act like it. Instead of sending <code>newObject</code> to the db for upsert like one might expect, it actually sends <code>{ $set: newObect }</code>. This means that it won&#8217;t totally replace any existing document, it will just update any fields attached to <code>newObject</code>. So if I mean to delete some fields by not sending them, I won&#8217;t be successful. Instead I&#8217;ll end up with a merged offspring of the old and new documents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">/*
 * No good: Will merge documents instead of replacing
 */
var firstVersion = { aNumericField: 14 };
model.findOneAndUpdate({ _id: 123 },
	firstVersion,
	{ upsert: true },
	callback);

// Stored in db:
// { _id: 123, aNumericField: 14 }

var secondVersion = { aStringField: 'cool' };
model.findOneAndUpdate({ _id: 123 },
	secondVersion,
	{ upsert: true },
	callback);

// Stored in db:
// { _id: 123, aNumericField: 14, aStringField: 'cool' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Mongoose documentation justifies this behavior with the argument that it prevents you from accidentally overwriting your documents. But what if I want to on purpose overwrite things? how do I do that?</p>
</div>
<div class="paragraph">
<p>I knew that I didn&#8217;t want to use <code>findOneAndUpdate</code>, because it works differently-than-guessable (a thing I try to avoid). But maybe I could combine <code>collection.update</code> with an explicit call to <code>document.validate()</code> to get the validation I wanted and the update behavior I expected.</p>
</div>
<div class="paragraph">
<p>But alas, this results in a new problem. <code>document.validate</code> will check each field defined in my schema, but any extra fields will be ignored by validation. This means that unexpected fields get a free ride into the database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">/*
 * No good: Will allow extra fields
 */
var weirdObject = { aNumericField: 14, weirdUnexpectedField: 'Tom Selleck' };
var weirdDocument = new CoolDocument(weirdObject);
weirdDocument.validate(function (err) {
	if (err) { throw new Error('Validation failed :('); }

	collection.update({ _id: 123 },
		weirdObject,
		{ upsert: true },
		callback);
});

// Stored in db:
// { _id: 123, aNumericField: 14, weirdUnexpectedField: 'Tom Selleck' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, after many hours of head banging, I discovered the the solution was to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>document.validate</code> to apply the schema validation</p>
</li>
<li>
<p>Call <code>document.toObject</code> to strip off any unexpected fields</p>
</li>
<li>
<p>Upsert the cleaned object with <code>collection.update</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If somehow you made it to the end of this post without seeing the working solution up top, please scroll up to the first code block now.</p>
</div>

    </div>
  </div>
</section>
<section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
